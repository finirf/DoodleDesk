# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

## Friends feature (Supabase setup)

To enable friend requests in the app, run this SQL in your Supabase SQL editor.

```sql
create table if not exists public.profiles (
	id uuid primary key references auth.users(id) on delete cascade,
	email text unique not null,
	created_at timestamptz not null default now()
);

create table if not exists public.friend_requests (
	id bigint generated by default as identity primary key,
	sender_id uuid not null references public.profiles(id) on delete cascade,
	receiver_id uuid not null references public.profiles(id) on delete cascade,
	status text not null default 'pending' check (status in ('pending', 'accepted', 'declined')),
	created_at timestamptz not null default now(),
	constraint friend_requests_sender_receiver_not_same check (sender_id <> receiver_id)
);

create table if not exists public.user_stats (
	user_id uuid primary key references public.profiles(id) on delete cascade,
	desks_created integer not null default 0,
	desks_deleted integer not null default 0,
	created_at timestamptz not null default now(),
	updated_at timestamptz not null default now()
);

create table if not exists public.desk_members (
	id bigint generated by default as identity primary key,
	desk_id uuid not null references public.desks(id) on delete cascade,
	user_id uuid not null references public.profiles(id) on delete cascade,
	created_at timestamptz not null default now(),
	unique (desk_id, user_id)
);

create table if not exists public.decorations (
	id bigint generated by default as identity primary key,
	desk_id uuid not null references public.desks(id) on delete cascade,
	kind text not null,
	x numeric not null default 0,
	y numeric not null default 0,
	rotation integer not null default 0,
	width integer not null default 88,
	height integer not null default 88,
	created_at timestamptz not null default now()
);

-- Optional but recommended: keeps a persistent collaborative marker on desks
alter table public.desks
	add column if not exists is_collaborative boolean not null default false;

-- Migration-safe cleanup for older versions that had a role column
alter table public.desk_members
	drop column if exists role;

alter table public.desk_members
	drop constraint if exists desk_members_role_check;

create unique index if not exists friend_requests_pair_unique
	on public.friend_requests (
		least(sender_id::text, receiver_id::text),
		greatest(sender_id::text, receiver_id::text)
	);

alter table public.profiles enable row level security;
alter table public.friend_requests enable row level security;
alter table public.user_stats enable row level security;
alter table public.desk_members enable row level security;
alter table public.decorations enable row level security;

drop policy if exists "profiles selectable by signed-in users" on public.profiles;
create policy "profiles selectable by signed-in users"
	on public.profiles for select
	to authenticated
	using (true);

drop policy if exists "users can upsert own profile" on public.profiles;
create policy "users can upsert own profile"
	on public.profiles for insert
	to authenticated
	with check (auth.uid() = id);

drop policy if exists "users can update own profile" on public.profiles;
create policy "users can update own profile"
	on public.profiles for update
	to authenticated
	using (auth.uid() = id)
	with check (auth.uid() = id);

drop policy if exists "users can read related friend requests" on public.friend_requests;
create policy "users can read related friend requests"
	on public.friend_requests for select
	to authenticated
	using (auth.uid() = sender_id or auth.uid() = receiver_id);

drop policy if exists "users can insert outgoing requests" on public.friend_requests;
create policy "users can insert outgoing requests"
	on public.friend_requests for insert
	to authenticated
	with check (auth.uid() = sender_id);

drop policy if exists "users can update incoming requests" on public.friend_requests;
create policy "users can update incoming requests"
	on public.friend_requests for update
	to authenticated
	using (auth.uid() = receiver_id)
	with check (auth.uid() = receiver_id);

drop policy if exists "users can delete outgoing pending requests" on public.friend_requests;
create policy "users can delete outgoing pending requests"
	on public.friend_requests for delete
	to authenticated
	using (auth.uid() = sender_id and status = 'pending');

drop policy if exists "users can read own stats" on public.user_stats;
create policy "users can read own stats"
	on public.user_stats for select
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "users can insert own stats" on public.user_stats;
create policy "users can insert own stats"
	on public.user_stats for insert
	to authenticated
	with check (auth.uid() = user_id);

drop policy if exists "users can update own stats" on public.user_stats;
create policy "users can update own stats"
	on public.user_stats for update
	to authenticated
	using (auth.uid() = user_id)
	with check (auth.uid() = user_id);

drop policy if exists "members can read desk memberships" on public.desk_members;
create policy "members can read desk memberships"
	on public.desk_members for select
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "owners can insert desk memberships" on public.desk_members;
create policy "owners can insert desk memberships"
	on public.desk_members for insert
	to authenticated
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	);

drop policy if exists "owners can update desk memberships" on public.desk_members;
create policy "owners can update desk memberships"
	on public.desk_members for update
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	)
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	);

drop policy if exists "owners can delete desk memberships" on public.desk_members;
create policy "owners can delete desk memberships"
	on public.desk_members for delete
	to authenticated
	using (
		auth.uid() = user_id
		or exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	);

drop policy if exists "owners and members can read desks" on public.desks;
create policy "owners and members can read desks"
	on public.desks for select
	to authenticated
	using (
		auth.uid() = user_id
		or exists (
			select 1
			from public.desk_members dm
			where dm.desk_id = desks.id
				and dm.user_id = auth.uid()
		)
	);

drop policy if exists "owners can insert desks" on public.desks;
create policy "owners can insert desks"
	on public.desks for insert
	to authenticated
	with check (auth.uid() = user_id);

drop policy if exists "owners can update desks" on public.desks;
create policy "owners can update desks"
	on public.desks for update
	to authenticated
	using (auth.uid() = user_id)
	with check (auth.uid() = user_id);

drop policy if exists "owners can delete desks" on public.desks;
create policy "owners can delete desks"
	on public.desks for delete
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "owners and members can read decorations" on public.decorations;
create policy "owners and members can read decorations"
	on public.decorations for select
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = decorations.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can insert decorations" on public.decorations;
create policy "owners and members can insert decorations"
	on public.decorations for insert
	to authenticated
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = decorations.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can update decorations" on public.decorations;
create policy "owners and members can update decorations"
	on public.decorations for update
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = decorations.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	)
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = decorations.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can delete decorations" on public.decorations;
create policy "owners and members can delete decorations"
	on public.decorations for delete
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = decorations.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

alter table public.notes enable row level security;
alter table public.checklists enable row level security;
alter table public.checklist_items enable row level security;

drop policy if exists "owners and members can read notes" on public.notes;
create policy "owners and members can read notes"
	on public.notes for select
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = notes.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can insert notes" on public.notes;
create policy "owners and members can insert notes"
	on public.notes for insert
	to authenticated
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = notes.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can update notes" on public.notes;
create policy "owners and members can update notes"
	on public.notes for update
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = notes.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	)
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = notes.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can delete notes" on public.notes;
create policy "owners and members can delete notes"
	on public.notes for delete
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = notes.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can read checklists" on public.checklists;
create policy "owners and members can read checklists"
	on public.checklists for select
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = checklists.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can insert checklists" on public.checklists;
create policy "owners and members can insert checklists"
	on public.checklists for insert
	to authenticated
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = checklists.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can update checklists" on public.checklists;
create policy "owners and members can update checklists"
	on public.checklists for update
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = checklists.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	)
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = checklists.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can delete checklists" on public.checklists;
create policy "owners and members can delete checklists"
	on public.checklists for delete
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = checklists.desk_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can read checklist items" on public.checklist_items;
create policy "owners and members can read checklist items"
	on public.checklist_items for select
	to authenticated
	using (
		exists (
			select 1
			from public.checklists c
			join public.desks d on d.id = c.desk_id
			where c.id = checklist_items.checklist_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can insert checklist items" on public.checklist_items;
create policy "owners and members can insert checklist items"
	on public.checklist_items for insert
	to authenticated
	with check (
		exists (
			select 1
			from public.checklists c
			join public.desks d on d.id = c.desk_id
			where c.id = checklist_items.checklist_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can update checklist items" on public.checklist_items;
create policy "owners and members can update checklist items"
	on public.checklist_items for update
	to authenticated
	using (
		exists (
			select 1
			from public.checklists c
			join public.desks d on d.id = c.desk_id
			where c.id = checklist_items.checklist_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	)
	with check (
		exists (
			select 1
			from public.checklists c
			join public.desks d on d.id = c.desk_id
			where c.id = checklist_items.checklist_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);

drop policy if exists "owners and members can delete checklist items" on public.checklist_items;
create policy "owners and members can delete checklist items"
	on public.checklist_items for delete
	to authenticated
	using (
		exists (
			select 1
			from public.checklists c
			join public.desks d on d.id = c.desk_id
			where c.id = checklist_items.checklist_id
				and (
					d.user_id = auth.uid()
					or exists (
						select 1
						from public.desk_members dm
						where dm.desk_id = d.id
							and dm.user_id = auth.uid()
					)
				)
		)
	);
```

## Text color migration (optional)

If your Supabase tables were created before text color support, run this SQL once:

```sql
alter table public.notes
	add column if not exists text_color text not null default '#222222';

alter table public.notes
	add column if not exists font_size integer not null default 16;

alter table public.checklists
	add column if not exists text_color text not null default '#222222';

alter table public.checklists
	add column if not exists font_size integer not null default 16;
```

## Rename existing folder tables to shelf tables (one-time migration)

If you already created the old `desk_folders` / `desk_folder_assignments` schema,
run this SQL once before using the new shelf-based app build:

```sql
do $$
begin
	if to_regclass('public.desk_shelves') is null
		and to_regclass('public.desk_folders') is not null then
		execute 'alter table public.desk_folders rename to desk_shelves';
	end if;

	if to_regclass('public.desk_shelf_assignments') is null
		and to_regclass('public.desk_folder_assignments') is not null then
		execute 'alter table public.desk_folder_assignments rename to desk_shelf_assignments';
	end if;
end
$$;

do $$
begin
	if exists (
		select 1
		from information_schema.columns
		where table_schema = 'public'
			and table_name = 'desk_shelf_assignments'
			and column_name = 'folder_id'
	)
	and not exists (
		select 1
		from information_schema.columns
		where table_schema = 'public'
			and table_name = 'desk_shelf_assignments'
			and column_name = 'shelf_id'
	) then
		execute 'alter table public.desk_shelf_assignments rename column folder_id to shelf_id';
	end if;
end
$$;

alter table public.desk_shelves
	alter column parent_id type uuid using nullif(parent_id::text, '')::uuid;

alter table public.desk_shelf_assignments
	alter column shelf_id type uuid using nullif(shelf_id::text, '')::uuid;

alter table public.desk_shelves
	drop constraint if exists desk_folders_parent_id_fkey;

alter table public.desk_shelves
	drop constraint if exists desk_shelves_parent_id_fkey;

alter table public.desk_shelves
	add constraint desk_shelves_parent_id_fkey
	foreign key (parent_id) references public.desk_shelves(id) on delete set null;

alter table public.desk_shelf_assignments
	drop constraint if exists desk_folder_assignments_folder_id_fkey;

alter table public.desk_shelf_assignments
	drop constraint if exists desk_shelf_assignments_shelf_id_fkey;

alter table public.desk_shelf_assignments
	add constraint desk_shelf_assignments_shelf_id_fkey
	foreign key (shelf_id) references public.desk_shelves(id) on delete cascade;

drop index if exists public.desk_folders_user_idx;
drop index if exists public.desk_folders_parent_idx;
drop index if exists public.desk_folder_assignments_user_idx;
drop index if exists public.desk_folder_assignments_folder_idx;

create index if not exists desk_shelves_user_idx
	on public.desk_shelves(user_id);

create index if not exists desk_shelves_parent_idx
	on public.desk_shelves(parent_id);

create index if not exists desk_shelf_assignments_user_idx
	on public.desk_shelf_assignments(user_id);

create index if not exists desk_shelf_assignments_shelf_idx
	on public.desk_shelf_assignments(shelf_id);

alter table public.desk_shelves enable row level security;
alter table public.desk_shelf_assignments enable row level security;

drop policy if exists "users can read own desk folders" on public.desk_shelves;
drop policy if exists "users can insert own desk folders" on public.desk_shelves;
drop policy if exists "users can update own desk folders" on public.desk_shelves;
drop policy if exists "users can delete own desk folders" on public.desk_shelves;

drop policy if exists "users can read own desk shelves" on public.desk_shelves;
drop policy if exists "users can insert own desk shelves" on public.desk_shelves;
drop policy if exists "users can update own desk shelves" on public.desk_shelves;
drop policy if exists "users can delete own desk shelves" on public.desk_shelves;

drop policy if exists "users can read own desk shelf assignments" on public.desk_shelf_assignments;
drop policy if exists "users can insert own desk shelf assignments" on public.desk_shelf_assignments;
drop policy if exists "users can update own desk shelf assignments" on public.desk_shelf_assignments;
drop policy if exists "users can delete own desk shelf assignments" on public.desk_shelf_assignments;

drop policy if exists "users can read own desk folder assignments" on public.desk_shelf_assignments;
drop policy if exists "users can insert own desk folder assignments" on public.desk_shelf_assignments;
drop policy if exists "users can update own desk folder assignments" on public.desk_shelf_assignments;
drop policy if exists "users can delete own desk folder assignments" on public.desk_shelf_assignments;

create policy "users can read own desk shelves"
	on public.desk_shelves for select
	to authenticated
	using (auth.uid() = user_id);

create policy "users can insert own desk shelves"
	on public.desk_shelves for insert
	to authenticated
	with check (auth.uid() = user_id);

create policy "users can update own desk shelves"
	on public.desk_shelves for update
	to authenticated
	using (auth.uid() = user_id)
	with check (auth.uid() = user_id);

create policy "users can delete own desk shelves"
	on public.desk_shelves for delete
	to authenticated
	using (auth.uid() = user_id);

create policy "users can read own desk shelf assignments"
	on public.desk_shelf_assignments for select
	to authenticated
	using (auth.uid() = user_id);

create policy "users can insert own desk shelf assignments"
	on public.desk_shelf_assignments for insert
	to authenticated
	with check (
		auth.uid() = user_id
		and exists (
			select 1
			from public.desk_shelves s
			where s.id = desk_shelf_assignments.shelf_id
				and s.user_id = auth.uid()
		)
	);

create policy "users can update own desk shelf assignments"
	on public.desk_shelf_assignments for update
	to authenticated
	using (auth.uid() = user_id)
	with check (
		auth.uid() = user_id
		and exists (
			select 1
			from public.desk_shelves s
			where s.id = desk_shelf_assignments.shelf_id
				and s.user_id = auth.uid()
		)
	);

create policy "users can delete own desk shelf assignments"
	on public.desk_shelf_assignments for delete
	to authenticated
	using (auth.uid() = user_id);
```

## Shelf hierarchy persistence (Supabase)

To persist the Shelf Organizer shelf hierarchy and desk-to-shelf assignments across devices/sessions,
run this SQL in Supabase:

```sql
create table if not exists public.desk_shelves (
	id uuid primary key,
	user_id uuid not null references public.profiles(id) on delete cascade,
	name text not null,
	parent_id uuid null references public.desk_shelves(id) on delete set null,
	created_at timestamptz not null default now(),
	updated_at timestamptz not null default now()
);

create table if not exists public.desk_shelf_assignments (
	user_id uuid not null references public.profiles(id) on delete cascade,
	desk_id uuid not null references public.desks(id) on delete cascade,
	shelf_id uuid not null references public.desk_shelves(id) on delete cascade,
	created_at timestamptz not null default now(),
	updated_at timestamptz not null default now(),
	primary key (user_id, desk_id)
);

-- Migration-safe: ensure older tables have required columns
alter table public.desk_shelves
	add column if not exists user_id uuid references public.profiles(id) on delete cascade;

alter table public.desk_shelves
	add column if not exists name text;

alter table public.desk_shelves
	add column if not exists parent_id uuid;

alter table public.desk_shelves
	add column if not exists created_at timestamptz not null default now();

alter table public.desk_shelves
	add column if not exists updated_at timestamptz not null default now();

alter table public.desk_shelf_assignments
	add column if not exists user_id uuid references public.profiles(id) on delete cascade;

alter table public.desk_shelf_assignments
	add column if not exists desk_id uuid references public.desks(id) on delete cascade;

alter table public.desk_shelf_assignments
	add column if not exists shelf_id uuid references public.desk_shelves(id) on delete cascade;

alter table public.desk_shelf_assignments
	add column if not exists created_at timestamptz not null default now();

alter table public.desk_shelf_assignments
	add column if not exists updated_at timestamptz not null default now();

-- Align legacy text columns to uuid when needed (safe for existing uuid columns)
alter table public.desk_shelves
	alter column parent_id type uuid using nullif(parent_id::text, '')::uuid;

alter table public.desk_shelf_assignments
	alter column shelf_id type uuid using nullif(shelf_id::text, '')::uuid;

-- Rebuild FK constraints safely for existing tables
alter table public.desk_shelves
	drop constraint if exists desk_shelves_parent_id_fkey;

alter table public.desk_shelves
	add constraint desk_shelves_parent_id_fkey
	foreign key (parent_id) references public.desk_shelves(id) on delete set null;

alter table public.desk_shelf_assignments
	drop constraint if exists desk_shelf_assignments_shelf_id_fkey;

alter table public.desk_shelf_assignments
	add constraint desk_shelf_assignments_shelf_id_fkey
	foreign key (shelf_id) references public.desk_shelves(id) on delete cascade;

create index if not exists desk_shelves_user_idx
	on public.desk_shelves(user_id);

create index if not exists desk_shelves_parent_idx
	on public.desk_shelves(parent_id);

create index if not exists desk_shelf_assignments_user_idx
	on public.desk_shelf_assignments(user_id);

create index if not exists desk_shelf_assignments_shelf_idx
	on public.desk_shelf_assignments(shelf_id);

alter table public.desk_shelves enable row level security;
alter table public.desk_shelf_assignments enable row level security;

drop policy if exists "users can read own desk shelves" on public.desk_shelves;
create policy "users can read own desk shelves"
	on public.desk_shelves for select
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "users can insert own desk shelves" on public.desk_shelves;
create policy "users can insert own desk shelves"
	on public.desk_shelves for insert
	to authenticated
	with check (auth.uid() = user_id);

drop policy if exists "users can update own desk shelves" on public.desk_shelves;
create policy "users can update own desk shelves"
	on public.desk_shelves for update
	to authenticated
	using (auth.uid() = user_id)
	with check (auth.uid() = user_id);

drop policy if exists "users can delete own desk shelves" on public.desk_shelves;
create policy "users can delete own desk shelves"
	on public.desk_shelves for delete
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "users can read own desk shelf assignments" on public.desk_shelf_assignments;
create policy "users can read own desk shelf assignments"
	on public.desk_shelf_assignments for select
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "users can insert own desk shelf assignments" on public.desk_shelf_assignments;
create policy "users can insert own desk shelf assignments"
	on public.desk_shelf_assignments for insert
	to authenticated
	with check (
		auth.uid() = user_id
		and exists (
			select 1
			from public.desk_shelves f
			where f.id = desk_shelf_assignments.shelf_id
				and f.user_id = auth.uid()
		)
	);

drop policy if exists "users can update own desk shelf assignments" on public.desk_shelf_assignments;
create policy "users can update own desk shelf assignments"
	on public.desk_shelf_assignments for update
	to authenticated
	using (auth.uid() = user_id)
	with check (
		auth.uid() = user_id
		and exists (
			select 1
			from public.desk_shelves f
			where f.id = desk_shelf_assignments.shelf_id
				and f.user_id = auth.uid()
		)
	);

drop policy if exists "users can delete own desk shelf assignments" on public.desk_shelf_assignments;
create policy "users can delete own desk shelf assignments"
	on public.desk_shelf_assignments for delete
	to authenticated
	using (auth.uid() = user_id);
```

## Full account deletion (including auth.users)

The Profile → Delete account button now calls a Supabase Edge Function named `delete-account`.
That function verifies the caller JWT and then uses the service role to delete the caller from `auth.users`.

### 1) SQL policy (run once)

```sql
alter table public.profiles enable row level security;

drop policy if exists "users can delete own profile" on public.profiles;
create policy "users can delete own profile"
	on public.profiles for delete
	to authenticated
	using (auth.uid() = id);
```

### 2) Deploy the Edge Function

The function file is already in this repo at:

- `supabase/functions/delete-account/index.ts`

Deploy it with Supabase CLI:

```bash
supabase functions deploy delete-account
```

If you run functions outside hosted Supabase defaults, make sure these secrets are available:

- `SUPABASE_URL`
- `SUPABASE_ANON_KEY`
- `SUPABASE_SERVICE_ROLE_KEY`

Set secrets (if needed):

```bash
supabase secrets set SUPABASE_URL=... SUPABASE_ANON_KEY=... SUPABASE_SERVICE_ROLE_KEY=...
```

After deployment, deleting an account removes the auth user and cascades related app data via your foreign keys.

## Friend request email notifications

You can email users whenever a new friend request is created and when a request is accepted by using a Supabase Edge Function + Database Webhook.

### 1) Deploy the Edge Function

Function path in this repo:

- `supabase/functions/friend-request-email/index.ts`

Deploy it:

```bash
supabase functions deploy friend-request-email
```

### 2) Set function secrets

The function expects:

- `RESEND_API_KEY`
- `FRIEND_REQUEST_FROM_EMAIL`
- `APP_BASE_URL`
- `FRIEND_REQUEST_WEBHOOK_SECRET`

Example:

```bash
supabase secrets set RESEND_API_KEY=your_resend_api_key
supabase secrets set FRIEND_REQUEST_FROM_EMAIL="DoodleDesk <noreply@yourdomain.com>"
supabase secrets set APP_BASE_URL="https://doodledesk-ten.vercel.app/"
supabase secrets set FRIEND_REQUEST_WEBHOOK_SECRET="replace-with-random-secret"
```

Notes:

- `FRIEND_REQUEST_FROM_EMAIL` must be verified with your email provider.
- `APP_BASE_URL` is used for the “Open DoodleDesk” email button.

### 3) Create a Supabase Database Webhook

In Supabase Dashboard:

- Go to `Database` → `Webhooks` → `Create a new webhook`
- Table: `public.friend_requests`
- Events: `INSERT`, `UPDATE`
- URL: `https://<your-project-ref>.functions.supabase.co/friend-request-email`
- Add header:
	- `x-webhook-secret: <same value as FRIEND_REQUEST_WEBHOOK_SECRET>`

The function sends emails only when:

- a new row is inserted with `status = 'pending'` (notifies receiver), or
- an existing row transitions to `status = 'accepted'` (notifies original sender).

### 4) Test

1. Send a friend request from one account to another.
2. Confirm email delivery for the receiver account.
3. Check function logs if needed:

```bash
supabase functions logs --name friend-request-email
```

## Collaborative desk member add-requests (owner approval)

To let collaborators request adding their own friends (with owner approval), run this SQL.

```sql
create table if not exists public.desk_member_requests (
	id bigint generated by default as identity primary key,
	desk_id uuid not null references public.desks(id) on delete cascade,
	requester_id uuid not null references public.profiles(id) on delete cascade,
	target_friend_id uuid not null references public.profiles(id) on delete cascade,
	owner_id uuid not null references public.profiles(id) on delete cascade,
	status text not null default 'pending' check (status in ('pending', 'approved', 'declined')),
	created_at timestamptz not null default now(),
	updated_at timestamptz not null default now(),
	constraint desk_member_requests_not_self check (requester_id <> target_friend_id)
);

create index if not exists desk_member_requests_desk_id_idx
	on public.desk_member_requests (desk_id, status, created_at desc);

create unique index if not exists desk_member_requests_pending_unique
	on public.desk_member_requests (desk_id, requester_id, target_friend_id, status)
	where status = 'pending';

alter table public.desk_member_requests enable row level security;

create or replace function public.is_desk_owner(_desk_id uuid, _uid uuid)
returns boolean
language sql
security definer
set search_path = public
as $$
	select exists (
		select 1
		from public.desks d
		where d.id = _desk_id
			and d.user_id = _uid
	);
$$;

create or replace function public.is_desk_member(_desk_id uuid, _uid uuid)
returns boolean
language sql
security definer
set search_path = public
as $$
	select exists (
		select 1
		from public.desk_members dm
		where dm.desk_id = _desk_id
			and dm.user_id = _uid
	);
$$;

revoke all on function public.is_desk_owner(uuid, uuid) from public;
grant execute on function public.is_desk_owner(uuid, uuid) to authenticated;
revoke all on function public.is_desk_member(uuid, uuid) from public;
grant execute on function public.is_desk_member(uuid, uuid) to authenticated;

drop policy if exists "owner and members can read desk memberships" on public.desk_members;
drop policy if exists "members can read desk memberships" on public.desk_members;
create policy "members and owners can read desk memberships"
	on public.desk_members for select
	to authenticated
	using (
		auth.uid() = user_id
		or public.is_desk_owner(desk_id, auth.uid())
		or public.is_desk_member(desk_id, auth.uid())
	);

drop policy if exists "owners and requesters can read member requests" on public.desk_member_requests;
create policy "owners and requesters can read member requests"
	on public.desk_member_requests for select
	to authenticated
	using (
		auth.uid() = requester_id
		or auth.uid() = owner_id
	);

drop policy if exists "members can insert member requests" on public.desk_member_requests;
create policy "members can insert member requests"
	on public.desk_member_requests for insert
	to authenticated
	with check (
		auth.uid() = requester_id
		and exists (
			select 1
			from public.desks d
			where d.id = desk_member_requests.desk_id
				and d.user_id = desk_member_requests.owner_id
				and d.is_collaborative = true
		)
		and exists (
			select 1
			from public.friend_requests fr
			where fr.status = 'accepted'
				and (
					(fr.sender_id = auth.uid() and fr.receiver_id = desk_member_requests.target_friend_id)
					or (fr.receiver_id = auth.uid() and fr.sender_id = desk_member_requests.target_friend_id)
				)
		)
	);

drop policy if exists "owners can update member requests" on public.desk_member_requests;
create policy "owners can update member requests"
	on public.desk_member_requests for update
	to authenticated
	using (auth.uid() = owner_id)
	with check (auth.uid() = owner_id);

-- One-time migration for legacy shared desks created before is_collaborative was used.
-- Marks any desk that already has members as collaborative.
update public.desks d
set is_collaborative = true
where coalesce(d.is_collaborative, false) = false
	and exists (
		select 1
		from public.desk_members dm
		where dm.desk_id = d.id
	);
```
