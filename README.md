# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

## Friends feature (Supabase setup)

To enable friend requests in the app, run this SQL in your Supabase SQL editor.

```sql
create table if not exists public.profiles (
	id uuid primary key references auth.users(id) on delete cascade,
	email text unique not null,
	created_at timestamptz not null default now()
);

create table if not exists public.friend_requests (
	id bigint generated by default as identity primary key,
	sender_id uuid not null references public.profiles(id) on delete cascade,
	receiver_id uuid not null references public.profiles(id) on delete cascade,
	status text not null default 'pending' check (status in ('pending', 'accepted', 'declined')),
	created_at timestamptz not null default now(),
	constraint friend_requests_sender_receiver_not_same check (sender_id <> receiver_id)
);

create table if not exists public.user_stats (
	user_id uuid primary key references public.profiles(id) on delete cascade,
	desks_created integer not null default 0,
	desks_deleted integer not null default 0,
	created_at timestamptz not null default now(),
	updated_at timestamptz not null default now()
);

create table if not exists public.desk_members (
	id bigint generated by default as identity primary key,
	desk_id uuid not null references public.desks(id) on delete cascade,
	user_id uuid not null references public.profiles(id) on delete cascade,
	role text not null default 'editor' check (role in ('owner', 'editor')),
	created_at timestamptz not null default now(),
	unique (desk_id, user_id)
);

create unique index if not exists friend_requests_pair_unique
	on public.friend_requests (
		least(sender_id::text, receiver_id::text),
		greatest(sender_id::text, receiver_id::text)
	);

alter table public.profiles enable row level security;
alter table public.friend_requests enable row level security;
alter table public.user_stats enable row level security;
alter table public.desk_members enable row level security;

drop policy if exists "profiles selectable by signed-in users" on public.profiles;
create policy "profiles selectable by signed-in users"
	on public.profiles for select
	to authenticated
	using (true);

drop policy if exists "users can upsert own profile" on public.profiles;
create policy "users can upsert own profile"
	on public.profiles for insert
	to authenticated
	with check (auth.uid() = id);

drop policy if exists "users can update own profile" on public.profiles;
create policy "users can update own profile"
	on public.profiles for update
	to authenticated
	using (auth.uid() = id)
	with check (auth.uid() = id);

drop policy if exists "users can read related friend requests" on public.friend_requests;
create policy "users can read related friend requests"
	on public.friend_requests for select
	to authenticated
	using (auth.uid() = sender_id or auth.uid() = receiver_id);

drop policy if exists "users can insert outgoing requests" on public.friend_requests;
create policy "users can insert outgoing requests"
	on public.friend_requests for insert
	to authenticated
	with check (auth.uid() = sender_id);

drop policy if exists "users can update incoming requests" on public.friend_requests;
create policy "users can update incoming requests"
	on public.friend_requests for update
	to authenticated
	using (auth.uid() = receiver_id)
	with check (auth.uid() = receiver_id);

drop policy if exists "users can delete outgoing pending requests" on public.friend_requests;
create policy "users can delete outgoing pending requests"
	on public.friend_requests for delete
	to authenticated
	using (auth.uid() = sender_id and status = 'pending');

drop policy if exists "users can read own stats" on public.user_stats;
create policy "users can read own stats"
	on public.user_stats for select
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "users can insert own stats" on public.user_stats;
create policy "users can insert own stats"
	on public.user_stats for insert
	to authenticated
	with check (auth.uid() = user_id);

drop policy if exists "users can update own stats" on public.user_stats;
create policy "users can update own stats"
	on public.user_stats for update
	to authenticated
	using (auth.uid() = user_id)
	with check (auth.uid() = user_id);

drop policy if exists "members can read desk memberships" on public.desk_members;
create policy "members can read desk memberships"
	on public.desk_members for select
	to authenticated
	using (auth.uid() = user_id);

drop policy if exists "owners can insert desk memberships" on public.desk_members;
create policy "owners can insert desk memberships"
	on public.desk_members for insert
	to authenticated
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	);

drop policy if exists "owners can update desk memberships" on public.desk_members;
create policy "owners can update desk memberships"
	on public.desk_members for update
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	)
	with check (
		exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	);

drop policy if exists "owners can delete desk memberships" on public.desk_members;
create policy "owners can delete desk memberships"
	on public.desk_members for delete
	to authenticated
	using (
		exists (
			select 1
			from public.desks d
			where d.id = desk_members.desk_id
				and d.user_id = auth.uid()
		)
	);

drop policy if exists "owners and members can read desks" on public.desks;
create policy "owners and members can read desks"
	on public.desks for select
	to authenticated
	using (
		auth.uid() = user_id
		or exists (
			select 1
			from public.desk_members dm
			where dm.desk_id = desks.id
				and dm.user_id = auth.uid()
		)
	);
```
