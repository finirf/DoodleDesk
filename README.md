# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

## Friends feature (Supabase setup)

To enable friend requests in the app, run this SQL in your Supabase SQL editor.

```sql
create table if not exists public.profiles (
	id uuid primary key references auth.users(id) on delete cascade,
	email text unique not null,
	created_at timestamptz not null default now()
);

create table if not exists public.friend_requests (
	id bigint generated by default as identity primary key,
	sender_id uuid not null references public.profiles(id) on delete cascade,
	receiver_id uuid not null references public.profiles(id) on delete cascade,
	status text not null default 'pending' check (status in ('pending', 'accepted', 'declined')),
	created_at timestamptz not null default now(),
	constraint friend_requests_sender_receiver_not_same check (sender_id <> receiver_id)
);

create unique index if not exists friend_requests_pair_unique
	on public.friend_requests (
		least(sender_id::text, receiver_id::text),
		greatest(sender_id::text, receiver_id::text)
	);

alter table public.profiles enable row level security;
alter table public.friend_requests enable row level security;

drop policy if exists "profiles selectable by signed-in users" on public.profiles;
create policy "profiles selectable by signed-in users"
	on public.profiles for select
	to authenticated
	using (true);

drop policy if exists "users can upsert own profile" on public.profiles;
create policy "users can upsert own profile"
	on public.profiles for insert
	to authenticated
	with check (auth.uid() = id);

drop policy if exists "users can update own profile" on public.profiles;
create policy "users can update own profile"
	on public.profiles for update
	to authenticated
	using (auth.uid() = id)
	with check (auth.uid() = id);

drop policy if exists "users can read related friend requests" on public.friend_requests;
create policy "users can read related friend requests"
	on public.friend_requests for select
	to authenticated
	using (auth.uid() = sender_id or auth.uid() = receiver_id);

drop policy if exists "users can insert outgoing requests" on public.friend_requests;
create policy "users can insert outgoing requests"
	on public.friend_requests for insert
	to authenticated
	with check (auth.uid() = sender_id);

drop policy if exists "users can update incoming requests" on public.friend_requests;
create policy "users can update incoming requests"
	on public.friend_requests for update
	to authenticated
	using (auth.uid() = receiver_id)
	with check (auth.uid() = receiver_id);

drop policy if exists "users can delete outgoing pending requests" on public.friend_requests;
create policy "users can delete outgoing pending requests"
	on public.friend_requests for delete
	to authenticated
	using (auth.uid() = sender_id and status = 'pending');
```
